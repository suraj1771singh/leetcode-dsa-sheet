import java.util.*;

//---------SIMPLE DFS
/* ALGO
1) color each node with differnt initial point(or can use parent concept)
2) if two node in initail have same color,those node can't be ans
3) among remaining initial node find the one highest component size
4) even if there are more then one potential ans,return with lowest ind value
 */
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        List<List<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++)
            adj.add(new ArrayList<>());
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++)
                if (i != j && graph[i][j] == 1) {
                    adj.get(i).add(j);
                    adj.get(j).add(i);
                }
        }

        int cnt[] = new int[n];
        int color[] = new int[n];
        for (int i = 0; i < n; i++)
            color[i] = i;
        for (int node : initial) {
            cnt[node] = dfs(node, -1, color, new boolean[n], adj);
        }
        int max = 0;
        for (int node : initial) {
            // initial node color should be same as initial node
            if (color[node] != node) {
                // two different inital node with same color
                color[node] = -1;
                if (color[node] != -1)
                    color[color[node]] = -1;
            }
        }
        int ans = -1;
        for (int node : initial) {
            if (color[node] == -1)
                continue;// can't be candidate for ans
            if (max == cnt[node]) {
                ans = ans > node ? node : ans;
            } else if (max < cnt[node]) {
                ans = node;
                max = cnt[node];
            }

        }
        return ans;

    }

    int dfs(int node, int parent, int[] color, boolean seen[], List<List<Integer>> adj) {
        int cnt = 1;
        seen[node] = true;
        if (parent != -1)
            color[node] = color[parent];
        for (int child : adj.get(node)) {
            if (!seen[child])
                cnt += dfs(child, node, color, seen, adj);
        }
        return cnt;
    }
}